# Syntax Analysis

The syntax of programming constructs are defined by CFGs of BNF form, and this is done because
1. A grammar gives a precise, yet easy to understand, syntactic specification of a programming language.
2. From classes of grammars, efficient parsers can be generated, that can reveal syntactic ambiguities and trouble spots.
3. Its structure is useful for translating source programs to object code
4. Allows evolution of language iteratively by adding new constructs with easy integration.

## The Role of the Parser

The parser obtains a string of tokens from the lexical analyser, and verifies that the string of token names can be generated by the grammmar for the source language. 

The parser constructs parse trees for well formed programs for further processing. The parse tree need not be constructed explicitly, since checking and translation actions can be interspersed with parsing. This allows the whole front end to be one module.

There are three general types of parsers
1. Universal
2. Top down
3. Bottom up

Universal parsing is usually omitted due to its high inefficiency in production compilers.

Top down parsers parse from the root to leaves, and the bottom up parsers do the opposite.

## Error Recovery

The simplest approach to handle parsing errors is to make the parser quit with an informative error message.

Additional errors are often uncovered if the parser can restore itself to a state where processing of input can continue with reasonable hopes that future processing woudl provided meaningful results.

### Panic Mode Recovery

In this, the parser discards input symbols one at a time until one of a designated set of synchronizing tokens is found. These are usually delimiters, such as ; or }, whose role in a source program is unambiguous.

This skips a considerable amount of input without checking additional errors, and has the advantage of simplicity, and guaranteed not going into an infinite loop.

### Phrase Level Recovery

On discovering an error, a parser may perform a local correction on the remaining input, to allow the parser to continue. Infinite loop generation must be handled, but the major drawback is when actual errors occur before the point of detection.

### Error Productions

By anticipating common errors, grammars can be augmented with productions that generate these errors, with correcting solutions as diagnostic messages.

### Global Corrections

For the compiler to make only a few changes in correcting the input string, a least cost corrections is done that minimises the number of edits. But this method is very costly, so is only introduced theoretically.

## Grammar Writing

### Elimination of Left Recursion

A grammar is left recursive if it has a non terminal A such that there is a derivation A -> Ab for some string b. Top down parsing cannot handle such grammars, so this needs to be eliminated.

This is done by
```
A -> cA'
A'-> bA' | e
```

So for any such productions
```
A -> Aa | Ab | Ac | .... | b1 | b2 | b3 | ....

All the A productions are replaced by

A -> b1A' | b2A' | ....
A'-> aA' | bA' | .....
```

### Left Factoring

Left factoring is done when the A-productions are not clear, where the instructions are rewritten to defer the decision enough to make the right choice.

For example
```
A -> ab | ad
is left fatored to
A -> aA'
A'-> b | d
```
