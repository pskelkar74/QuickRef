# Exploiting ILP, TLP and DLP with the Polymorphous TRIPS Architecture

## Abstract

The paper describes the <b>polymorphous</b> TRIPS architecture which can be configured for different granularities and types of parallelism. It contains mechanisms that enable processing cores and the on-chip memory systems to be configured and combined in different modes for ILP, DLP and TLP. The TRIPS architecture contains 4 out of order, 16 wide issue grid processor cores, that can be partitioned when easily extractable fine-grained parallelism exists. This provides better performance. 

## A Grid Processor Architecture (GPA)

Physical limits processor clock rate imply that future performance improvements come from better ILP and TLP. A GPA is a 2D array of nodes, where each node has a single instruction buffer and a single execution unit. Compiler detects the parallelism and schedules instructions. Execution units can be heterogeneous, but add a cost to complexity. This offers greater scalability than conventional architectures.

Each instruction group is statically mapped to a GPA node during compile time. Execution proceeds as
- Instruction buffer is populated first
- The block is executed
- Group outputs are forwarded to node with next block

This allows
- Large instruction groups
- No centralised data structures
- Heterogeneity

## Polymorphism and the TRIPS Architecture

Polymorphism is the on-the-fly hardware configuration for efficient execution across various application classes. The TRIPS architecture contains 4 large cores, with 16 nodes each. Each node can handle a hyperblock of upto 128 instructions and contains an integer ALU, FPU, reservation stations and router connections.


The major morphs included are
1. D-morph (Desktop Morph)
   - ILP
   - Out of Order execution with associative cache
   - Branch Prediction
   - Instruction buffer is treated as a distributed instruction issue window
   - A hyperblock is
     - Single entry, multiple branch block of instructions
     - VLIW like units for branch prediction
   - High bandwidth, low latency instruction fetch
   - Branch misprediction can cause large performance losses
   - Works with single threaded code
2. T-Morph (Threaded Morph)
   - TLP
   - Requires multithreads
   - High processor utilisation
   - Cores allocated to each thread before execution
   - Separate PC for each thread
   - TRIPS implements as
     - Physical frames partitioned apriori and assigned to threads
     - In each threads, frames are divided into some number of A frames and speculative execution is allowed within each thread
3. S-Morph
   - DLP
