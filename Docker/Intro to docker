Lecture 1

Why do we need docker?
1. The matrix of hell is a compatibility matrix to be made on every OS to link application stacks to the environment
2. Compatibility was an issue.
3. Modify the underlying frameworks without setting up entire application or service stacks.
4. Docker helps containerize applications.
5. Containers are isolated environments that share the same kernel, unlike virtual machines.
6. Docker uses LXC Containers. 

Sharing a kernel - Run any OS on top of a kernel if its the same type of OS kernel (Linux maybe)
Windows based containers cant be run with linux on it, for example. When a linux container is made to run on windows,
windows makes a linux virtual machine run the docker container.

Unlike hypervisors, docker doesnt run kernels. Docker just containerizes them.

Containers vs VMs
1. Docker sits on top of the OS, and manages the containers. The Hypervisor in a VM makes an OS on top of the OS.
2. VMs take higher disk space, docker is light.
3. Docker has less isolation because it runs on the same OS kernel, VMs have complete isolation.
4. You usually use containers in VMs to use both technologies.

How is it done?
1. DockerHub has some images already made and published to use on the fly.
2. docker run ansible, docker run nodejs, etc all work.
3. It can run many instances of the same machine, with a configured load balancer
4. Fault control also works by just destroying instances.

Containers vs images
1. Docker containers run images in them
2. Images have a package, a template and a plan
3. Devs give the prerequisities and dependencies to Ops, but they cant set up the applications. In docker,
the DevOps work hand in hand through docker images. Ops can just deploy it directly.

Lecture 2 + install

Docker has two editions
1. Community : Free
2. Enterprise: For companies, management and etc, not free

Lecture 3

docker run -                            runs docker image; looks locally, if not found goes to DockerHub
docker ps -                             show running container
docker ps -a -                          all containers run or stopped
docker stop <container id or name> -    stop container
docker rm -                             Remove a stopped container
docker images -                         lists all images on the host
docker rmi <container name> -           removes the image
docker pull -                           pulls image, dont run the container

Unlike VMs, containers are not meant to host OS's, they just host applications. So they run the task and exit.
The container lives only as long as the process inside it is living.

docker exec -                           Run a command on a docker container

When a docker container is run in the foreground, the stdout is your only interface when it is running

docker run -d -                         Run a command in the background mode to use other things
docker attach <id> -                    Go into a container in background mode

Lecture 4

The tag specifies a version to an image. If no tag is specified, the latest one is used.
By default, docker run does not read a standard input, and runs in a non interactive mode.

The -i parameter allows the container to be run in interactive mode
The application -it allows you to make a pseudo terminal to the docker interactive CLI

Docker host is the system on which the docker image runs
The application listens on a port, and is accessed using this port.
The IP is the docker container's default IP and is an internal IP only accessible on the docker host.
The IP of the docker host can be used, but the port inside the docker container must be mapped to the host of the
machine running the application.

docker run -p 80:5000 routes all traffic of 8080 to 5000. This allows a lot of instances to be run simultaneously
on the host containers.

Volume mapping is done in docker to persist data on a docker container. -v allows this volume mapping to a persisted 
disk on the system.

Additional details about a specific container are given by docker inspect <container-name>

The logs of a containerized application can be viewed through docker logs

Lecture 5

Environment variables are set using -e with docker. These can configure the application without explicitly editing the
file

These environment variables can be found in the inspect.

Lecture 6

To create an image, make a file called DockerFile.
Sample DockerFile

FROM Ubuntu

RUN apt-get install python
RUN pip install flask
RUN pip install flask-mysql

COPY ./opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run

Then build it it locally using docker build DockerFile -t <path>

docker push uploads it to the DockerHub

A DockerFile is structured as INSTRUCTION and ARGUMENT. Here, FROM is an INSTRUCTION and Ubuntu is an ARGUMENT

All DockerFiles must start with a FROM instruction to start from a base OS

The ENTRYPOINT specifies a command to be run when the image is run as a container

Each INSTRUCTION makes a new layer in the container when the docker build command is used.

docker history <image> tells you the size taken in each layer.

All layers are cached, incase of failure, or updates, the build takes lesser time.

Lecture 7